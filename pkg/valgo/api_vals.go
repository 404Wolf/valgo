/*
Val Town API

Val Townâ€™s public API  OpenAPI JSON endpoint:  https://api.val.town/openapi.json

API version: 1
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// ValsAPIService ValsAPI service
type ValsAPIService service

type ApiRunGetRequest struct {
	ctx context.Context
	ApiService *ValsAPIService
	valname string
	args *string
}

// An argument that will be passed to the function as a JavaScript value
func (r ApiRunGetRequest) Args(args string) ApiRunGetRequest {
	r.args = &args
	return r
}

func (r ApiRunGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.RunGetExecute(r)
}

/*
RunGet Method for RunGet

Run a val, specify any parameters in a querystring

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param valname Name of the val, in concatenated style, like username.valname
 @return ApiRunGetRequest

Deprecated
*/
func (a *ValsAPIService) RunGet(ctx context.Context, valname string) ApiRunGetRequest {
	return ApiRunGetRequest{
		ApiService: a,
		ctx: ctx,
		valname: valname,
	}
}

// Execute executes the request
// Deprecated
func (a *ValsAPIService) RunGetExecute(r ApiRunGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ValsAPIService.RunGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/run/{valname}"
	localVarPath = strings.Replace(localVarPath, "{"+"valname"+"}", url.PathEscape(parameterValueToString(r.valname, "valname")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.args != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "args", r.args, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiRunPostRequest struct {
	ctx context.Context
	ApiService *ValsAPIService
	valname string
	runPostRequest *RunPostRequest
}

// Arguments to call the method with
func (r ApiRunPostRequest) RunPostRequest(runPostRequest RunPostRequest) ApiRunPostRequest {
	r.runPostRequest = &runPostRequest
	return r
}

func (r ApiRunPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.RunPostExecute(r)
}

/*
RunPost Method for RunPost

Run a val, with arguments in the request body

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param valname Name of the val, in concatenated style, like username.valname
 @return ApiRunPostRequest

Deprecated
*/
func (a *ValsAPIService) RunPost(ctx context.Context, valname string) ApiRunPostRequest {
	return ApiRunPostRequest{
		ApiService: a,
		ctx: ctx,
		valname: valname,
	}
}

// Execute executes the request
// Deprecated
func (a *ValsAPIService) RunPostExecute(r ApiRunPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ValsAPIService.RunPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/run/{valname}"
	localVarPath = strings.Replace(localVarPath, "{"+"valname"+"}", url.PathEscape(parameterValueToString(r.valname, "valname")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.runPostRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiValsCancelRequest struct {
	ctx context.Context
	ApiService *ValsAPIService
	valId string
	evaluationId string
}

func (r ApiValsCancelRequest) Execute() (*ValsCancel200Response, *http.Response, error) {
	return r.ApiService.ValsCancelExecute(r)
}

/*
ValsCancel Method for ValsCancel

Cancel a running val

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param valId Id of a val
 @param evaluationId The ID of the evaluation - the specific time that a val was run - that you want to cancel
 @return ApiValsCancelRequest
*/
func (a *ValsAPIService) ValsCancel(ctx context.Context, valId string, evaluationId string) ApiValsCancelRequest {
	return ApiValsCancelRequest{
		ApiService: a,
		ctx: ctx,
		valId: valId,
		evaluationId: evaluationId,
	}
}

// Execute executes the request
//  @return ValsCancel200Response
func (a *ValsAPIService) ValsCancelExecute(r ApiValsCancelRequest) (*ValsCancel200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ValsCancel200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ValsAPIService.ValsCancel")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/vals/{val_id}/evaluations/{evaluation_id}/cancel"
	localVarPath = strings.Replace(localVarPath, "{"+"val_id"+"}", url.PathEscape(parameterValueToString(r.valId, "valId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"evaluation_id"+"}", url.PathEscape(parameterValueToString(r.evaluationId, "evaluationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiValsCreateRequest struct {
	ctx context.Context
	ApiService *ValsAPIService
	valsCreateRequest *ValsCreateRequest
}

// Val information provided to create a new val
func (r ApiValsCreateRequest) ValsCreateRequest(valsCreateRequest ValsCreateRequest) ApiValsCreateRequest {
	r.valsCreateRequest = &valsCreateRequest
	return r
}

func (r ApiValsCreateRequest) Execute() (*ExtendedVal, *http.Response, error) {
	return r.ApiService.ValsCreateExecute(r)
}

/*
ValsCreate Method for ValsCreate

Create a new val

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiValsCreateRequest
*/
func (a *ValsAPIService) ValsCreate(ctx context.Context) ApiValsCreateRequest {
	return ApiValsCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ExtendedVal
func (a *ValsAPIService) ValsCreateExecute(r ApiValsCreateRequest) (*ExtendedVal, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ExtendedVal
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ValsAPIService.ValsCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/vals"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.valsCreateRequest == nil {
		return localVarReturnValue, nil, reportError("valsCreateRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.valsCreateRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiValsCreateVersionRequest struct {
	ctx context.Context
	ApiService *ValsAPIService
	valId string
	valsCreateRequest *ValsCreateRequest
}

// Val information provided to create a new val
func (r ApiValsCreateVersionRequest) ValsCreateRequest(valsCreateRequest ValsCreateRequest) ApiValsCreateVersionRequest {
	r.valsCreateRequest = &valsCreateRequest
	return r
}

func (r ApiValsCreateVersionRequest) Execute() (*ExtendedVal, *http.Response, error) {
	return r.ApiService.ValsCreateVersionExecute(r)
}

/*
ValsCreateVersion Method for ValsCreateVersion

Create a new version of a val

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param valId Id of a val
 @return ApiValsCreateVersionRequest
*/
func (a *ValsAPIService) ValsCreateVersion(ctx context.Context, valId string) ApiValsCreateVersionRequest {
	return ApiValsCreateVersionRequest{
		ApiService: a,
		ctx: ctx,
		valId: valId,
	}
}

// Execute executes the request
//  @return ExtendedVal
func (a *ValsAPIService) ValsCreateVersionExecute(r ApiValsCreateVersionRequest) (*ExtendedVal, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ExtendedVal
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ValsAPIService.ValsCreateVersion")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/vals/{val_id}/versions"
	localVarPath = strings.Replace(localVarPath, "{"+"val_id"+"}", url.PathEscape(parameterValueToString(r.valId, "valId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.valsCreateRequest == nil {
		return localVarReturnValue, nil, reportError("valsCreateRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.valsCreateRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiValsDeleteRequest struct {
	ctx context.Context
	ApiService *ValsAPIService
	valId string
}

func (r ApiValsDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.ValsDeleteExecute(r)
}

/*
ValsDelete Method for ValsDelete

Delete a val

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param valId Id of a val
 @return ApiValsDeleteRequest
*/
func (a *ValsAPIService) ValsDelete(ctx context.Context, valId string) ApiValsDeleteRequest {
	return ApiValsDeleteRequest{
		ApiService: a,
		ctx: ctx,
		valId: valId,
	}
}

// Execute executes the request
func (a *ValsAPIService) ValsDeleteExecute(r ApiValsDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ValsAPIService.ValsDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/vals/{val_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"val_id"+"}", url.PathEscape(parameterValueToString(r.valId, "valId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiValsDeleteVersionRequest struct {
	ctx context.Context
	ApiService *ValsAPIService
	valId string
	version int32
}

func (r ApiValsDeleteVersionRequest) Execute() (*http.Response, error) {
	return r.ApiService.ValsDeleteVersionExecute(r)
}

/*
ValsDeleteVersion Method for ValsDeleteVersion

Delete a specific version of a val

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param valId Id of a val
 @param version The val version
 @return ApiValsDeleteVersionRequest
*/
func (a *ValsAPIService) ValsDeleteVersion(ctx context.Context, valId string, version int32) ApiValsDeleteVersionRequest {
	return ApiValsDeleteVersionRequest{
		ApiService: a,
		ctx: ctx,
		valId: valId,
		version: version,
	}
}

// Execute executes the request
func (a *ValsAPIService) ValsDeleteVersionExecute(r ApiValsDeleteVersionRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ValsAPIService.ValsDeleteVersion")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/vals/{val_id}/versions/{version}"
	localVarPath = strings.Replace(localVarPath, "{"+"val_id"+"}", url.PathEscape(parameterValueToString(r.valId, "valId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.version < 0 {
		return nil, reportError("version must be greater than 0")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiValsGetRequest struct {
	ctx context.Context
	ApiService *ValsAPIService
	valId string
}

func (r ApiValsGetRequest) Execute() (*ExtendedVal, *http.Response, error) {
	return r.ApiService.ValsGetExecute(r)
}

/*
ValsGet Method for ValsGet

Get a val by id

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param valId Id of a val
 @return ApiValsGetRequest
*/
func (a *ValsAPIService) ValsGet(ctx context.Context, valId string) ApiValsGetRequest {
	return ApiValsGetRequest{
		ApiService: a,
		ctx: ctx,
		valId: valId,
	}
}

// Execute executes the request
//  @return ExtendedVal
func (a *ValsAPIService) ValsGetExecute(r ApiValsGetRequest) (*ExtendedVal, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ExtendedVal
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ValsAPIService.ValsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/vals/{val_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"val_id"+"}", url.PathEscape(parameterValueToString(r.valId, "valId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiValsGetVersionRequest struct {
	ctx context.Context
	ApiService *ValsAPIService
	offset *int32
	limit *int32
	valId string
	version int32
}

// Number of items to skip in order to deliver paginated results
func (r ApiValsGetVersionRequest) Offset(offset int32) ApiValsGetVersionRequest {
	r.offset = &offset
	return r
}

// Maximum items to return in each paginated response
func (r ApiValsGetVersionRequest) Limit(limit int32) ApiValsGetVersionRequest {
	r.limit = &limit
	return r
}

func (r ApiValsGetVersionRequest) Execute() (*ExtendedVal, *http.Response, error) {
	return r.ApiService.ValsGetVersionExecute(r)
}

/*
ValsGetVersion Method for ValsGetVersion

Get a specific version of a val

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param valId Id of a val
 @param version The val version
 @return ApiValsGetVersionRequest
*/
func (a *ValsAPIService) ValsGetVersion(ctx context.Context, valId string, version int32) ApiValsGetVersionRequest {
	return ApiValsGetVersionRequest{
		ApiService: a,
		ctx: ctx,
		valId: valId,
		version: version,
	}
}

// Execute executes the request
//  @return ExtendedVal
func (a *ValsAPIService) ValsGetVersionExecute(r ApiValsGetVersionRequest) (*ExtendedVal, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ExtendedVal
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ValsAPIService.ValsGetVersion")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/vals/{val_id}/versions/{version}"
	localVarPath = strings.Replace(localVarPath, "{"+"val_id"+"}", url.PathEscape(parameterValueToString(r.valId, "valId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.offset == nil {
		return localVarReturnValue, nil, reportError("offset is required and must be specified")
	}
	if *r.offset < 0 {
		return localVarReturnValue, nil, reportError("offset must be greater than 0")
	}
	if r.limit == nil {
		return localVarReturnValue, nil, reportError("limit is required and must be specified")
	}
	if *r.limit < 1 {
		return localVarReturnValue, nil, reportError("limit must be greater than 1")
	}
	if *r.limit > 100 {
		return localVarReturnValue, nil, reportError("limit must be less than 100")
	}
	if r.version < 0 {
		return localVarReturnValue, nil, reportError("version must be greater than 0")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiValsListRequest struct {
	ctx context.Context
	ApiService *ValsAPIService
	offset *int32
	limit *int32
	valId string
}

// Number of items to skip in order to deliver paginated results
func (r ApiValsListRequest) Offset(offset int32) ApiValsListRequest {
	r.offset = &offset
	return r
}

// Maximum items to return in each paginated response
func (r ApiValsListRequest) Limit(limit int32) ApiValsListRequest {
	r.limit = &limit
	return r
}

func (r ApiValsListRequest) Execute() (*ValsList200Response, *http.Response, error) {
	return r.ApiService.ValsListExecute(r)
}

/*
ValsList Method for ValsList

List versions of a val

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param valId Id of a val
 @return ApiValsListRequest
*/
func (a *ValsAPIService) ValsList(ctx context.Context, valId string) ApiValsListRequest {
	return ApiValsListRequest{
		ApiService: a,
		ctx: ctx,
		valId: valId,
	}
}

// Execute executes the request
//  @return ValsList200Response
func (a *ValsAPIService) ValsListExecute(r ApiValsListRequest) (*ValsList200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ValsList200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ValsAPIService.ValsList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/vals/{val_id}/versions"
	localVarPath = strings.Replace(localVarPath, "{"+"val_id"+"}", url.PathEscape(parameterValueToString(r.valId, "valId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.offset == nil {
		return localVarReturnValue, nil, reportError("offset is required and must be specified")
	}
	if *r.offset < 0 {
		return localVarReturnValue, nil, reportError("offset must be greater than 0")
	}
	if r.limit == nil {
		return localVarReturnValue, nil, reportError("limit is required and must be specified")
	}
	if *r.limit < 1 {
		return localVarReturnValue, nil, reportError("limit must be greater than 1")
	}
	if *r.limit > 100 {
		return localVarReturnValue, nil, reportError("limit must be less than 100")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiValsPutRequest struct {
	ctx context.Context
	ApiService *ValsAPIService
	valsPutRequest *ValsPutRequest
}

// Create a new val, or version of a val, with new code
func (r ApiValsPutRequest) ValsPutRequest(valsPutRequest ValsPutRequest) ApiValsPutRequest {
	r.valsPutRequest = &valsPutRequest
	return r
}

func (r ApiValsPutRequest) Execute() (*http.Response, error) {
	return r.ApiService.ValsPutExecute(r)
}

/*
ValsPut Method for ValsPut

Run an existing val or create a new one

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiValsPutRequest
*/
func (a *ValsAPIService) ValsPut(ctx context.Context) ApiValsPutRequest {
	return ApiValsPutRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *ValsAPIService) ValsPutExecute(r ApiValsPutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ValsAPIService.ValsPut")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/vals"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.valsPutRequest == nil {
		return nil, reportError("valsPutRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.valsPutRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiValsUpdateRequest struct {
	ctx context.Context
	ApiService *ValsAPIService
	valId string
	valsUpdateRequest *ValsUpdateRequest
}

// Note: you must supply at least one of the keys in this object in order to update a val
func (r ApiValsUpdateRequest) ValsUpdateRequest(valsUpdateRequest ValsUpdateRequest) ApiValsUpdateRequest {
	r.valsUpdateRequest = &valsUpdateRequest
	return r
}

func (r ApiValsUpdateRequest) Execute() (*http.Response, error) {
	return r.ApiService.ValsUpdateExecute(r)
}

/*
ValsUpdate Method for ValsUpdate

Update an existing val

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param valId Id of a val
 @return ApiValsUpdateRequest
*/
func (a *ValsAPIService) ValsUpdate(ctx context.Context, valId string) ApiValsUpdateRequest {
	return ApiValsUpdateRequest{
		ApiService: a,
		ctx: ctx,
		valId: valId,
	}
}

// Execute executes the request
func (a *ValsAPIService) ValsUpdateExecute(r ApiValsUpdateRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ValsAPIService.ValsUpdate")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/vals/{val_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"val_id"+"}", url.PathEscape(parameterValueToString(r.valId, "valId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.valsUpdateRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
